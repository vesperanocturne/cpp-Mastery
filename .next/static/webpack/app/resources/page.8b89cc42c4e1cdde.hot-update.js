"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/resources/page",{

/***/ "(app-pages-browser)/./src/lib/downloadUtils.ts":
/*!**********************************!*\
  !*** ./src/lib/downloadUtils.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadCheatSheet: () => (/* binding */ downloadCheatSheet),\n/* harmony export */   downloadCodeTemplate: () => (/* binding */ downloadCodeTemplate),\n/* harmony export */   downloadCourseCode: () => (/* binding */ downloadCourseCode),\n/* harmony export */   downloadFile: () => (/* binding */ downloadFile),\n/* harmony export */   downloadProjectStarterCode: () => (/* binding */ downloadProjectStarterCode),\n/* harmony export */   generateCheatSheetContent: () => (/* binding */ generateCheatSheetContent),\n/* harmony export */   generateCodeTemplate: () => (/* binding */ generateCodeTemplate),\n/* harmony export */   generateZipContent: () => (/* binding */ generateZipContent)\n/* harmony export */ });\n// Utility functions for generating and downloading files\n/**\r\n * Downloads a file to the user's computer\r\n */ function downloadFile(file) {\n    const blob = file.content instanceof Blob ? file.content : new Blob([\n        file.content\n    ], {\n        type: getMimeType(file.type)\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = file.name;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n}\n/**\r\n * Gets MIME type based on file extension\r\n */ function getMimeType(type) {\n    const mimeTypes = {\n        'PDF': 'application/pdf',\n        'CPP': 'text/plain',\n        'ZIP': 'application/zip',\n        'HTML': 'text/html',\n        'TXT': 'text/plain'\n    };\n    return mimeTypes[type.toUpperCase()] || 'application/octet-stream';\n}\n/**\r\n * Generates a C++ code template based on the template name\r\n */ function generateCodeTemplate(templateName) {\n    const templates = {\n        'Class Template Boilerplate': '#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nclass MyClass {\\nprivate:\\n    // Private member variables\\n    string name;\\n    int value;\\n\\npublic:\\n    // Constructor\\n    MyClass(string n, int v) : name(n), value(v) {}\\n    \\n    // Destructor\\n    ~MyClass() {\\n        cout << \"Object destroyed\" << endl;\\n    }\\n    \\n    // Getter methods\\n    string getName() const { return name; }\\n    int getValue() const { return value; }\\n    \\n    // Setter methods\\n    void setName(string n) { name = n; }\\n    void setValue(int v) { value = v; }\\n    \\n    // Member function\\n    void display() const {\\n        cout << \"Name: \" << name << \", Value: \" << value << endl;\\n    }\\n};\\n\\nint main() {\\n    MyClass obj(\"Example\", 42);\\n    obj.display();\\n    return 0;\\n}',\n        'Algorithm Templates': '#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\n// Binary Search Template\\nint binarySearch(vector<int>& arr, int target) {\\n    int left = 0, right = arr.size() - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (arr[mid] == target) return mid;\\n        if (arr[mid] < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n    return -1;\\n}\\n\\n// Quick Sort Template\\nvoid quickSort(vector<int>& arr, int low, int high) {\\n    if (low < high) {\\n        int pivot = arr[high];\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (arr[j] < pivot) {\\n                i++;\\n                swap(arr[i], arr[j]);\\n            }\\n        }\\n        swap(arr[i + 1], arr[high]);\\n        int pi = i + 1;\\n        quickSort(arr, low, pi - 1);\\n        quickSort(arr, pi + 1, high);\\n    }\\n}\\n\\nint main() {\\n    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};\\n    quickSort(arr, 0, arr.size() - 1);\\n    for (int x : arr) cout << x << \" \";\\n    return 0;\\n}',\n        'Data Structure Templates': \"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <stack>\\nusing namespace std;\\n\\n// Linked List Node\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int x) : val(x), next(nullptr) {}\\n};\\n\\n// Binary Tree Node\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n};\\n\\n// Stack Implementation\\nclass MyStack {\\nprivate:\\n    vector<int> data;\\npublic:\\n    void push(int x) { data.push_back(x); }\\n    void pop() { data.pop_back(); }\\n    int top() { return data.back(); }\\n    bool empty() { return data.empty(); }\\n};\\n\\n// Queue Implementation\\nclass MyQueue {\\nprivate:\\n    vector<int> data;\\npublic:\\n    void enqueue(int x) { data.push_back(x); }\\n    void dequeue() { data.erase(data.begin()); }\\n    int front() { return data.front(); }\\n    bool empty() { return data.empty(); }\\n};\\n\\nint main() {\\n    MyStack s;\\n    s.push(1);\\n    s.push(2);\\n    cout << s.top() << endl;\\n    return 0;\\n}\"\n    };\n    return templates[templateName] || \"// \".concat(templateName, \"\\n// Template code here\\n\");\n}\n/**\r\n * Generates a PDF-like text content for cheat sheets\r\n */ function generateCheatSheetContent(sheetName) {\n    const sheets = {\n        'Basic Syntax Cheat Sheet': \"C++ BASIC SYNTAX CHEAT SHEET\\n=====================================\\n\\nVARIABLES & DATA TYPES\\n----------------------\\nint age = 25;\\nfloat height = 5.9f;\\ndouble salary = 50000.50;\\nchar grade = 'A';\\nbool isStudent = true;\\nstring name = \\\"John\\\";\\n\\nCONTROL FLOW\\n------------\\nif (condition) { }\\nelse if (condition) { }\\nelse { }\\n\\nfor (int i = 0; i < n; i++) { }\\nwhile (condition) { }\\ndo { } while (condition);\\n\\nswitch (value) {\\n    case 1: break;\\n    default: break;\\n}\\n\\nFUNCTIONS\\n---------\\nreturnType functionName(params) {\\n    return value;\\n}\\n\\nvoid functionName() { }\\n\\nCLASSES\\n-------\\nclass ClassName {\\nprivate:\\n    int privateVar;\\npublic:\\n    ClassName() { }\\n    ~ClassName() { }\\n    void method() { }\\n};\\n\\nPOINTERS & REFERENCES\\n---------------------\\nint* ptr = &variable;\\nint& ref = variable;\\n*ptr = value;\\n\\nSTANDARD LIBRARY\\n----------------\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\",\n        'STL Containers Reference': 'C++ STL CONTAINERS REFERENCE\\n=============================\\n\\nVECTOR\\n------\\nvector<int> v;\\nv.push_back(10);\\nv.pop_back();\\nv.size();\\nv.empty();\\nv[i];\\n\\nLIST\\n----\\nlist<int> l;\\nl.push_back(10);\\nl.push_front(5);\\nl.pop_back();\\nl.pop_front();\\n\\nMAP\\n---\\nmap<string, int> m;\\nm[\"key\"] = value;\\nm.find(\"key\");\\nm.erase(\"key\");\\n\\nSET\\n---\\nset<int> s;\\ns.insert(10);\\ns.find(10);\\ns.erase(10);\\n\\nQUEUE\\n-----\\nqueue<int> q;\\nq.push(10);\\nq.pop();\\nq.front();\\nq.empty();\\n\\nSTACK\\n-----\\nstack<int> s;\\ns.push(10);\\ns.pop();\\ns.top();\\ns.empty();',\n        'OOP Concepts Guide': \"C++ OBJECT-ORIENTED PROGRAMMING GUIDE\\n=====================================\\n\\nENCAPSULATION\\n-------------\\n- Private members: Only accessible within class\\n- Protected members: Accessible in class and derived classes\\n- Public members: Accessible everywhere\\n\\nINHERITANCE\\n-----------\\nclass Base {\\n    // base class members\\n};\\n\\nclass Derived : public Base {\\n    // derived class members\\n};\\n\\nPOLYMORPHISM\\n------------\\n- Function Overriding: Redefine base class function\\n- Virtual Functions: Enable runtime polymorphism\\n- Abstract Classes: Classes with pure virtual functions\\n\\nABSTRACTION\\n-----------\\n- Hide implementation details\\n- Show only essential features\\n- Use abstract classes and interfaces\\n\\nKEYWORDS\\n--------\\nvirtual: Enable polymorphism\\noverride: Explicitly override base function\\nfinal: Prevent further overriding\\nabstract: Pure virtual functions\",\n        'Modern C++ Features': 'MODERN C++ FEATURES (C++11/14/17/20)\\n====================================\\n\\nAUTO KEYWORD\\n------------\\nauto x = 10;\\nauto name = \"C++\";\\n\\nRANGE-BASED FOR LOOP\\n--------------------\\nfor (auto& item : container) {\\n    // process item\\n}\\n\\nSMART POINTERS\\n--------------\\nunique_ptr<T> ptr = make_unique<T>();\\nshared_ptr<T> ptr = make_shared<T>();\\nweak_ptr<T> ptr;\\n\\nLAMBDA EXPRESSIONS\\n------------------\\nauto lambda = [](int x) { return x * 2; };\\nsort(v.begin(), v.end(), [](int a, int b) {\\n    return a < b;\\n});\\n\\nNULLPTR\\n-------\\nint* ptr = nullptr;  // instead of NULL\\n\\nINITIALIZER LISTS\\n-----------------\\nvector<int> v = {1, 2, 3, 4};\\nmap<string, int> m = {{\"a\", 1}, {\"b\", 2}};'\n    };\n    return sheets[sheetName] || \"# \".concat(sheetName, \"\\n\\nContent here...\\n\");\n}\n/**\r\n * Generates a ZIP file content (simplified - creates a text representation)\r\n * Note: For actual ZIP files, you'd need a library like JSZip\r\n */ function generateZipContent(items) {\n    return items.join('\\n\\n---FILE SEPARATOR---\\n\\n');\n}\n/**\r\n * Downloads a cheat sheet as PDF (text-based for now)\r\n */ function downloadCheatSheet(sheetName) {\n    const content = generateCheatSheetContent(sheetName);\n    downloadFile({\n        name: \"\".concat(sheetName.replace(/\\s+/g, '_'), \".txt\"),\n        type: 'PDF',\n        content: content\n    });\n}\n/**\r\n * Downloads a code template\r\n */ function downloadCodeTemplate(templateName) {\n    const content = generateCodeTemplate(templateName);\n    downloadFile({\n        name: \"\".concat(templateName.replace(/\\s+/g, '_'), \".cpp\"),\n        type: 'CPP',\n        content: content\n    });\n}\n/**\r\n * Downloads course code examples as ZIP\r\n */ function downloadCourseCode(courseTitle, lessons) {\n    const codeFiles = lessons.filter((lesson)=>lesson.codeExample).map((lesson, index)=>\"// \".concat(lesson.title, \"\\n\").concat(lesson.codeExample, \"\\n\"));\n    const content = codeFiles.join('\\n\\n// ============================================\\n\\n');\n    downloadFile({\n        name: \"\".concat(courseTitle.replace(/\\s+/g, '_'), \"_Code_Examples.txt\"),\n        type: 'ZIP',\n        content: content\n    });\n}\n/**\r\n * Downloads project starter code\r\n */ function downloadProjectStarterCode(projectTitle, starterCode) {\n    // Escape quotes in project title for C++ string literal\n    const escapedTitle = projectTitle.replace(/\"/g, '\\\\\"');\n    const code = starterCode || \"// \".concat(projectTitle, ' Starter Code\\n#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    // Your code here\\n    cout << \"Hello, ').concat(escapedTitle, '!\" << endl;\\n    return 0;\\n}');\n    downloadFile({\n        name: \"\".concat(projectTitle.replace(/\\s+/g, '_'), \"_starter.cpp\"),\n        type: 'CPP',\n        content: code\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG93bmxvYWRVdGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHlEQUF5RDtBQVF6RDs7Q0FFQyxHQUNNLFNBQVNBLGFBQWFDLElBQWtCO0lBQzdDLE1BQU1DLE9BQU9ELEtBQUtFLE9BQU8sWUFBWUMsT0FDakNILEtBQUtFLE9BQU8sR0FDWixJQUFJQyxLQUFLO1FBQUNILEtBQUtFLE9BQU87S0FBQyxFQUFFO1FBQUVFLE1BQU1DLFlBQVlMLEtBQUtJLElBQUk7SUFBRTtJQUU1RCxNQUFNRSxNQUFNQyxJQUFJQyxlQUFlLENBQUNQO0lBQ2hDLE1BQU1RLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztJQUNwQ0YsS0FBS0csSUFBSSxHQUFHTjtJQUNaRyxLQUFLSSxRQUFRLEdBQUdiLEtBQUtjLElBQUk7SUFDekJKLFNBQVNLLElBQUksQ0FBQ0MsV0FBVyxDQUFDUDtJQUMxQkEsS0FBS1EsS0FBSztJQUNWUCxTQUFTSyxJQUFJLENBQUNHLFdBQVcsQ0FBQ1Q7SUFDMUJGLElBQUlZLGVBQWUsQ0FBQ2I7QUFDdEI7QUFFQTs7Q0FFQyxHQUNELFNBQVNELFlBQVlELElBQVk7SUFDL0IsTUFBTWdCLFlBQW9DO1FBQ3hDLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUNQLFFBQVE7UUFDUixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxTQUFTLENBQUNoQixLQUFLaUIsV0FBVyxHQUFHLElBQUk7QUFDMUM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLHFCQUFxQkMsWUFBb0I7SUFDdkQsTUFBTUMsWUFBb0M7UUFDeEMsOEJBQStCO1FBc0MvQix1QkFBd0I7UUF5Q3hCLDRCQUE2QjtJQWtEL0I7SUFFQSxPQUFPQSxTQUFTLENBQUNELGFBQWEsSUFBSSxNQUFtQixPQUFiQSxjQUFhO0FBQ3ZEO0FBRUE7O0NBRUMsR0FDTSxTQUFTRSwwQkFBMEJDLFNBQWlCO0lBQ3pELE1BQU1DLFNBQWlDO1FBQ3JDLDRCQUE2QjtRQTJEN0IsNEJBQTZCO1FBaUQ3QixzQkFBdUI7UUFxQ3ZCLHVCQUF3QjtJQW1DMUI7SUFFQSxPQUFPQSxNQUFNLENBQUNELFVBQVUsSUFBSSxLQUFlLE9BQVZBLFdBQVU7QUFDN0M7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRSxtQkFBbUJDLEtBQWU7SUFDaEQsT0FBT0EsTUFBTUMsSUFBSSxDQUFDO0FBQ3BCO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxtQkFBbUJMLFNBQWlCO0lBQ2xELE1BQU14QixVQUFVdUIsMEJBQTBCQztJQUMxQzNCLGFBQWE7UUFDWGUsTUFBTSxHQUFrQyxPQUEvQlksVUFBVU0sT0FBTyxDQUFDLFFBQVEsTUFBSztRQUN4QzVCLE1BQU07UUFDTkYsU0FBU0E7SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTK0IscUJBQXFCVixZQUFvQjtJQUN2RCxNQUFNckIsVUFBVW9CLHFCQUFxQkM7SUFDckN4QixhQUFhO1FBQ1hlLE1BQU0sR0FBcUMsT0FBbENTLGFBQWFTLE9BQU8sQ0FBQyxRQUFRLE1BQUs7UUFDM0M1QixNQUFNO1FBQ05GLFNBQVNBO0lBQ1g7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU2dDLG1CQUFtQkMsV0FBbUIsRUFBRUMsT0FBYztJQUNwRSxNQUFNQyxZQUFZRCxRQUNmRSxNQUFNLENBQUNDLENBQUFBLFNBQVVBLE9BQU9DLFdBQVcsRUFDbkNDLEdBQUcsQ0FBQyxDQUFDRixRQUFRRyxRQUFVLE1BQXVCSCxPQUFqQkEsT0FBT0ksS0FBSyxFQUFDLE1BQXVCLE9BQW5CSixPQUFPQyxXQUFXLEVBQUM7SUFFcEUsTUFBTXRDLFVBQVVtQyxVQUFVUCxJQUFJLENBQUM7SUFDL0IvQixhQUFhO1FBQ1hlLE1BQU0sR0FBb0MsT0FBakNxQixZQUFZSCxPQUFPLENBQUMsUUFBUSxNQUFLO1FBQzFDNUIsTUFBTTtRQUNORixTQUFTQTtJQUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVMwQywyQkFBMkJDLFlBQW9CLEVBQUVDLFdBQW9CO0lBQ25GLHdEQUF3RDtJQUN4RCxNQUFNQyxlQUFlRixhQUFhYixPQUFPLENBQUMsTUFBTTtJQUNoRCxNQUFNZ0IsT0FBT0YsZUFBZSxNQU1SQyxPQU5jRixjQUFhLHlIQU1kLE9BQWJFLGNBQWE7SUFJakNoRCxhQUFhO1FBQ1hlLE1BQU0sR0FBcUMsT0FBbEMrQixhQUFhYixPQUFPLENBQUMsUUFBUSxNQUFLO1FBQzNDNUIsTUFBTTtRQUNORixTQUFTOEM7SUFDWDtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHByaXlhXFxPbmVEcml2ZVxcRG9jdW1lbnRzXFxHaXRIdWJcXGNwcC1NYXN0ZXJ5XFxzcmNcXGxpYlxcZG93bmxvYWRVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZ2VuZXJhdGluZyBhbmQgZG93bmxvYWRpbmcgZmlsZXNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRG93bmxvYWRGaWxlIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG4gIGNvbnRlbnQ6IHN0cmluZyB8IEJsb2I7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb3dubG9hZHMgYSBmaWxlIHRvIHRoZSB1c2VyJ3MgY29tcHV0ZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEZpbGUoZmlsZTogRG93bmxvYWRGaWxlKSB7XHJcbiAgY29uc3QgYmxvYiA9IGZpbGUuY29udGVudCBpbnN0YW5jZW9mIEJsb2IgXHJcbiAgICA/IGZpbGUuY29udGVudCBcclxuICAgIDogbmV3IEJsb2IoW2ZpbGUuY29udGVudF0sIHsgdHlwZTogZ2V0TWltZVR5cGUoZmlsZS50eXBlKSB9KTtcclxuICBcclxuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgbGluay5ocmVmID0gdXJsO1xyXG4gIGxpbmsuZG93bmxvYWQgPSBmaWxlLm5hbWU7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuICBsaW5rLmNsaWNrKCk7XHJcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIE1JTUUgdHlwZSBiYXNlZCBvbiBmaWxlIGV4dGVuc2lvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWltZVR5cGUodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBtaW1lVHlwZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAnUERGJzogJ2FwcGxpY2F0aW9uL3BkZicsXHJcbiAgICAnQ1BQJzogJ3RleHQvcGxhaW4nLFxyXG4gICAgJ1pJUCc6ICdhcHBsaWNhdGlvbi96aXAnLFxyXG4gICAgJ0hUTUwnOiAndGV4dC9odG1sJyxcclxuICAgICdUWFQnOiAndGV4dC9wbGFpbidcclxuICB9O1xyXG4gIHJldHVybiBtaW1lVHlwZXNbdHlwZS50b1VwcGVyQ2FzZSgpXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIEMrKyBjb2RlIHRlbXBsYXRlIGJhc2VkIG9uIHRoZSB0ZW1wbGF0ZSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlVGVtcGxhdGUodGVtcGxhdGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IHRlbXBsYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICdDbGFzcyBUZW1wbGF0ZSBCb2lsZXJwbGF0ZSc6IGAjaW5jbHVkZSA8aW9zdHJlYW0+XHJcbiNpbmNsdWRlIDxzdHJpbmc+XHJcbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XHJcblxyXG5jbGFzcyBNeUNsYXNzIHtcclxucHJpdmF0ZTpcclxuICAgIC8vIFByaXZhdGUgbWVtYmVyIHZhcmlhYmxlc1xyXG4gICAgc3RyaW5nIG5hbWU7XHJcbiAgICBpbnQgdmFsdWU7XHJcblxyXG5wdWJsaWM6XHJcbiAgICAvLyBDb25zdHJ1Y3RvclxyXG4gICAgTXlDbGFzcyhzdHJpbmcgbiwgaW50IHYpIDogbmFtZShuKSwgdmFsdWUodikge31cclxuICAgIFxyXG4gICAgLy8gRGVzdHJ1Y3RvclxyXG4gICAgfk15Q2xhc3MoKSB7XHJcbiAgICAgICAgY291dCA8PCBcIk9iamVjdCBkZXN0cm95ZWRcIiA8PCBlbmRsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZXR0ZXIgbWV0aG9kc1xyXG4gICAgc3RyaW5nIGdldE5hbWUoKSBjb25zdCB7IHJldHVybiBuYW1lOyB9XHJcbiAgICBpbnQgZ2V0VmFsdWUoKSBjb25zdCB7IHJldHVybiB2YWx1ZTsgfVxyXG4gICAgXHJcbiAgICAvLyBTZXR0ZXIgbWV0aG9kc1xyXG4gICAgdm9pZCBzZXROYW1lKHN0cmluZyBuKSB7IG5hbWUgPSBuOyB9XHJcbiAgICB2b2lkIHNldFZhbHVlKGludCB2KSB7IHZhbHVlID0gdjsgfVxyXG4gICAgXHJcbiAgICAvLyBNZW1iZXIgZnVuY3Rpb25cclxuICAgIHZvaWQgZGlzcGxheSgpIGNvbnN0IHtcclxuICAgICAgICBjb3V0IDw8IFwiTmFtZTogXCIgPDwgbmFtZSA8PCBcIiwgVmFsdWU6IFwiIDw8IHZhbHVlIDw8IGVuZGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5pbnQgbWFpbigpIHtcclxuICAgIE15Q2xhc3Mgb2JqKFwiRXhhbXBsZVwiLCA0Mik7XHJcbiAgICBvYmouZGlzcGxheSgpO1xyXG4gICAgcmV0dXJuIDA7XHJcbn1gLFxyXG4gICAgJ0FsZ29yaXRobSBUZW1wbGF0ZXMnOiBgI2luY2x1ZGUgPGlvc3RyZWFtPlxyXG4jaW5jbHVkZSA8dmVjdG9yPlxyXG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxyXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xyXG5cclxuLy8gQmluYXJ5IFNlYXJjaCBUZW1wbGF0ZVxyXG5pbnQgYmluYXJ5U2VhcmNoKHZlY3RvcjxpbnQ+JiBhcnIsIGludCB0YXJnZXQpIHtcclxuICAgIGludCBsZWZ0ID0gMCwgcmlnaHQgPSBhcnIuc2l6ZSgpIC0gMTtcclxuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XHJcbiAgICAgICAgaW50IG1pZCA9IGxlZnQgKyAocmlnaHQgLSBsZWZ0KSAvIDI7XHJcbiAgICAgICAgaWYgKGFyclttaWRdID09IHRhcmdldCkgcmV0dXJuIG1pZDtcclxuICAgICAgICBpZiAoYXJyW21pZF0gPCB0YXJnZXQpIGxlZnQgPSBtaWQgKyAxO1xyXG4gICAgICAgIGVsc2UgcmlnaHQgPSBtaWQgLSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBRdWljayBTb3J0IFRlbXBsYXRlXHJcbnZvaWQgcXVpY2tTb3J0KHZlY3RvcjxpbnQ+JiBhcnIsIGludCBsb3csIGludCBoaWdoKSB7XHJcbiAgICBpZiAobG93IDwgaGlnaCkge1xyXG4gICAgICAgIGludCBwaXZvdCA9IGFycltoaWdoXTtcclxuICAgICAgICBpbnQgaSA9IGxvdyAtIDE7XHJcbiAgICAgICAgZm9yIChpbnQgaiA9IGxvdzsgaiA8IGhpZ2g7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyW2pdIDwgcGl2b3QpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIHN3YXAoYXJyW2ldLCBhcnJbal0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3YXAoYXJyW2kgKyAxXSwgYXJyW2hpZ2hdKTtcclxuICAgICAgICBpbnQgcGkgPSBpICsgMTtcclxuICAgICAgICBxdWlja1NvcnQoYXJyLCBsb3csIHBpIC0gMSk7XHJcbiAgICAgICAgcXVpY2tTb3J0KGFyciwgcGkgKyAxLCBoaWdoKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50IG1haW4oKSB7XHJcbiAgICB2ZWN0b3I8aW50PiBhcnIgPSB7NjQsIDM0LCAyNSwgMTIsIDIyLCAxMSwgOTB9O1xyXG4gICAgcXVpY2tTb3J0KGFyciwgMCwgYXJyLnNpemUoKSAtIDEpO1xyXG4gICAgZm9yIChpbnQgeCA6IGFycikgY291dCA8PCB4IDw8IFwiIFwiO1xyXG4gICAgcmV0dXJuIDA7XHJcbn1gLFxyXG4gICAgJ0RhdGEgU3RydWN0dXJlIFRlbXBsYXRlcyc6IGAjaW5jbHVkZSA8aW9zdHJlYW0+XHJcbiNpbmNsdWRlIDx2ZWN0b3I+XHJcbiNpbmNsdWRlIDxxdWV1ZT5cclxuI2luY2x1ZGUgPHN0YWNrPlxyXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xyXG5cclxuLy8gTGlua2VkIExpc3QgTm9kZVxyXG5zdHJ1Y3QgTGlzdE5vZGUge1xyXG4gICAgaW50IHZhbDtcclxuICAgIExpc3ROb2RlKiBuZXh0O1xyXG4gICAgTGlzdE5vZGUoaW50IHgpIDogdmFsKHgpLCBuZXh0KG51bGxwdHIpIHt9XHJcbn07XHJcblxyXG4vLyBCaW5hcnkgVHJlZSBOb2RlXHJcbnN0cnVjdCBUcmVlTm9kZSB7XHJcbiAgICBpbnQgdmFsO1xyXG4gICAgVHJlZU5vZGUqIGxlZnQ7XHJcbiAgICBUcmVlTm9kZSogcmlnaHQ7XHJcbiAgICBUcmVlTm9kZShpbnQgeCkgOiB2YWwoeCksIGxlZnQobnVsbHB0ciksIHJpZ2h0KG51bGxwdHIpIHt9XHJcbn07XHJcblxyXG4vLyBTdGFjayBJbXBsZW1lbnRhdGlvblxyXG5jbGFzcyBNeVN0YWNrIHtcclxucHJpdmF0ZTpcclxuICAgIHZlY3RvcjxpbnQ+IGRhdGE7XHJcbnB1YmxpYzpcclxuICAgIHZvaWQgcHVzaChpbnQgeCkgeyBkYXRhLnB1c2hfYmFjayh4KTsgfVxyXG4gICAgdm9pZCBwb3AoKSB7IGRhdGEucG9wX2JhY2soKTsgfVxyXG4gICAgaW50IHRvcCgpIHsgcmV0dXJuIGRhdGEuYmFjaygpOyB9XHJcbiAgICBib29sIGVtcHR5KCkgeyByZXR1cm4gZGF0YS5lbXB0eSgpOyB9XHJcbn07XHJcblxyXG4vLyBRdWV1ZSBJbXBsZW1lbnRhdGlvblxyXG5jbGFzcyBNeVF1ZXVlIHtcclxucHJpdmF0ZTpcclxuICAgIHZlY3RvcjxpbnQ+IGRhdGE7XHJcbnB1YmxpYzpcclxuICAgIHZvaWQgZW5xdWV1ZShpbnQgeCkgeyBkYXRhLnB1c2hfYmFjayh4KTsgfVxyXG4gICAgdm9pZCBkZXF1ZXVlKCkgeyBkYXRhLmVyYXNlKGRhdGEuYmVnaW4oKSk7IH1cclxuICAgIGludCBmcm9udCgpIHsgcmV0dXJuIGRhdGEuZnJvbnQoKTsgfVxyXG4gICAgYm9vbCBlbXB0eSgpIHsgcmV0dXJuIGRhdGEuZW1wdHkoKTsgfVxyXG59O1xyXG5cclxuaW50IG1haW4oKSB7XHJcbiAgICBNeVN0YWNrIHM7XHJcbiAgICBzLnB1c2goMSk7XHJcbiAgICBzLnB1c2goMik7XHJcbiAgICBjb3V0IDw8IHMudG9wKCkgPDwgZW5kbDtcclxuICAgIHJldHVybiAwO1xyXG59YFxyXG4gIH07XHJcbiAgXHJcbiAgcmV0dXJuIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdIHx8IGAvLyAke3RlbXBsYXRlTmFtZX1cXG4vLyBUZW1wbGF0ZSBjb2RlIGhlcmVcXG5gO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgUERGLWxpa2UgdGV4dCBjb250ZW50IGZvciBjaGVhdCBzaGVldHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoZWF0U2hlZXRDb250ZW50KHNoZWV0TmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBzaGVldHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAnQmFzaWMgU3ludGF4IENoZWF0IFNoZWV0JzogYEMrKyBCQVNJQyBTWU5UQVggQ0hFQVQgU0hFRVRcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuVkFSSUFCTEVTICYgREFUQSBUWVBFU1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmludCBhZ2UgPSAyNTtcclxuZmxvYXQgaGVpZ2h0ID0gNS45ZjtcclxuZG91YmxlIHNhbGFyeSA9IDUwMDAwLjUwO1xyXG5jaGFyIGdyYWRlID0gJ0EnO1xyXG5ib29sIGlzU3R1ZGVudCA9IHRydWU7XHJcbnN0cmluZyBuYW1lID0gXCJKb2huXCI7XHJcblxyXG5DT05UUk9MIEZMT1dcclxuLS0tLS0tLS0tLS0tXHJcbmlmIChjb25kaXRpb24pIHsgfVxyXG5lbHNlIGlmIChjb25kaXRpb24pIHsgfVxyXG5lbHNlIHsgfVxyXG5cclxuZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspIHsgfVxyXG53aGlsZSAoY29uZGl0aW9uKSB7IH1cclxuZG8geyB9IHdoaWxlIChjb25kaXRpb24pO1xyXG5cclxuc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgY2FzZSAxOiBicmVhaztcclxuICAgIGRlZmF1bHQ6IGJyZWFrO1xyXG59XHJcblxyXG5GVU5DVElPTlNcclxuLS0tLS0tLS0tXHJcbnJldHVyblR5cGUgZnVuY3Rpb25OYW1lKHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG52b2lkIGZ1bmN0aW9uTmFtZSgpIHsgfVxyXG5cclxuQ0xBU1NFU1xyXG4tLS0tLS0tXHJcbmNsYXNzIENsYXNzTmFtZSB7XHJcbnByaXZhdGU6XHJcbiAgICBpbnQgcHJpdmF0ZVZhcjtcclxucHVibGljOlxyXG4gICAgQ2xhc3NOYW1lKCkgeyB9XHJcbiAgICB+Q2xhc3NOYW1lKCkgeyB9XHJcbiAgICB2b2lkIG1ldGhvZCgpIHsgfVxyXG59O1xyXG5cclxuUE9JTlRFUlMgJiBSRUZFUkVOQ0VTXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5pbnQqIHB0ciA9ICZ2YXJpYWJsZTtcclxuaW50JiByZWYgPSB2YXJpYWJsZTtcclxuKnB0ciA9IHZhbHVlO1xyXG5cclxuU1RBTkRBUkQgTElCUkFSWVxyXG4tLS0tLS0tLS0tLS0tLS0tXHJcbiNpbmNsdWRlIDxpb3N0cmVhbT5cclxuI2luY2x1ZGUgPHZlY3Rvcj5cclxuI2luY2x1ZGUgPHN0cmluZz5cclxuI2luY2x1ZGUgPGFsZ29yaXRobT5cclxudXNpbmcgbmFtZXNwYWNlIHN0ZDtgLFxyXG4gICAgJ1NUTCBDb250YWluZXJzIFJlZmVyZW5jZSc6IGBDKysgU1RMIENPTlRBSU5FUlMgUkVGRVJFTkNFXHJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5WRUNUT1JcclxuLS0tLS0tXHJcbnZlY3RvcjxpbnQ+IHY7XHJcbnYucHVzaF9iYWNrKDEwKTtcclxudi5wb3BfYmFjaygpO1xyXG52LnNpemUoKTtcclxudi5lbXB0eSgpO1xyXG52W2ldO1xyXG5cclxuTElTVFxyXG4tLS0tXHJcbmxpc3Q8aW50PiBsO1xyXG5sLnB1c2hfYmFjaygxMCk7XHJcbmwucHVzaF9mcm9udCg1KTtcclxubC5wb3BfYmFjaygpO1xyXG5sLnBvcF9mcm9udCgpO1xyXG5cclxuTUFQXHJcbi0tLVxyXG5tYXA8c3RyaW5nLCBpbnQ+IG07XHJcbm1bXCJrZXlcIl0gPSB2YWx1ZTtcclxubS5maW5kKFwia2V5XCIpO1xyXG5tLmVyYXNlKFwia2V5XCIpO1xyXG5cclxuU0VUXHJcbi0tLVxyXG5zZXQ8aW50PiBzO1xyXG5zLmluc2VydCgxMCk7XHJcbnMuZmluZCgxMCk7XHJcbnMuZXJhc2UoMTApO1xyXG5cclxuUVVFVUVcclxuLS0tLS1cclxucXVldWU8aW50PiBxO1xyXG5xLnB1c2goMTApO1xyXG5xLnBvcCgpO1xyXG5xLmZyb250KCk7XHJcbnEuZW1wdHkoKTtcclxuXHJcblNUQUNLXHJcbi0tLS0tXHJcbnN0YWNrPGludD4gcztcclxucy5wdXNoKDEwKTtcclxucy5wb3AoKTtcclxucy50b3AoKTtcclxucy5lbXB0eSgpO2AsXHJcbiAgICAnT09QIENvbmNlcHRzIEd1aWRlJzogYEMrKyBPQkpFQ1QtT1JJRU5URUQgUFJPR1JBTU1JTkcgR1VJREVcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuRU5DQVBTVUxBVElPTlxyXG4tLS0tLS0tLS0tLS0tXHJcbi0gUHJpdmF0ZSBtZW1iZXJzOiBPbmx5IGFjY2Vzc2libGUgd2l0aGluIGNsYXNzXHJcbi0gUHJvdGVjdGVkIG1lbWJlcnM6IEFjY2Vzc2libGUgaW4gY2xhc3MgYW5kIGRlcml2ZWQgY2xhc3Nlc1xyXG4tIFB1YmxpYyBtZW1iZXJzOiBBY2Nlc3NpYmxlIGV2ZXJ5d2hlcmVcclxuXHJcbklOSEVSSVRBTkNFXHJcbi0tLS0tLS0tLS0tXHJcbmNsYXNzIEJhc2Uge1xyXG4gICAgLy8gYmFzZSBjbGFzcyBtZW1iZXJzXHJcbn07XHJcblxyXG5jbGFzcyBEZXJpdmVkIDogcHVibGljIEJhc2Uge1xyXG4gICAgLy8gZGVyaXZlZCBjbGFzcyBtZW1iZXJzXHJcbn07XHJcblxyXG5QT0xZTU9SUEhJU01cclxuLS0tLS0tLS0tLS0tXHJcbi0gRnVuY3Rpb24gT3ZlcnJpZGluZzogUmVkZWZpbmUgYmFzZSBjbGFzcyBmdW5jdGlvblxyXG4tIFZpcnR1YWwgRnVuY3Rpb25zOiBFbmFibGUgcnVudGltZSBwb2x5bW9ycGhpc21cclxuLSBBYnN0cmFjdCBDbGFzc2VzOiBDbGFzc2VzIHdpdGggcHVyZSB2aXJ0dWFsIGZ1bmN0aW9uc1xyXG5cclxuQUJTVFJBQ1RJT05cclxuLS0tLS0tLS0tLS1cclxuLSBIaWRlIGltcGxlbWVudGF0aW9uIGRldGFpbHNcclxuLSBTaG93IG9ubHkgZXNzZW50aWFsIGZlYXR1cmVzXHJcbi0gVXNlIGFic3RyYWN0IGNsYXNzZXMgYW5kIGludGVyZmFjZXNcclxuXHJcbktFWVdPUkRTXHJcbi0tLS0tLS0tXHJcbnZpcnR1YWw6IEVuYWJsZSBwb2x5bW9ycGhpc21cclxub3ZlcnJpZGU6IEV4cGxpY2l0bHkgb3ZlcnJpZGUgYmFzZSBmdW5jdGlvblxyXG5maW5hbDogUHJldmVudCBmdXJ0aGVyIG92ZXJyaWRpbmdcclxuYWJzdHJhY3Q6IFB1cmUgdmlydHVhbCBmdW5jdGlvbnNgLFxyXG4gICAgJ01vZGVybiBDKysgRmVhdHVyZXMnOiBgTU9ERVJOIEMrKyBGRUFUVVJFUyAoQysrMTEvMTQvMTcvMjApXHJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuQVVUTyBLRVlXT1JEXHJcbi0tLS0tLS0tLS0tLVxyXG5hdXRvIHggPSAxMDtcclxuYXV0byBuYW1lID0gXCJDKytcIjtcclxuXHJcblJBTkdFLUJBU0VEIEZPUiBMT09QXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmZvciAoYXV0byYgaXRlbSA6IGNvbnRhaW5lcikge1xyXG4gICAgLy8gcHJvY2VzcyBpdGVtXHJcbn1cclxuXHJcblNNQVJUIFBPSU5URVJTXHJcbi0tLS0tLS0tLS0tLS0tXHJcbnVuaXF1ZV9wdHI8VD4gcHRyID0gbWFrZV91bmlxdWU8VD4oKTtcclxuc2hhcmVkX3B0cjxUPiBwdHIgPSBtYWtlX3NoYXJlZDxUPigpO1xyXG53ZWFrX3B0cjxUPiBwdHI7XHJcblxyXG5MQU1CREEgRVhQUkVTU0lPTlNcclxuLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmF1dG8gbGFtYmRhID0gW10oaW50IHgpIHsgcmV0dXJuIHggKiAyOyB9O1xyXG5zb3J0KHYuYmVnaW4oKSwgdi5lbmQoKSwgW10oaW50IGEsIGludCBiKSB7XHJcbiAgICByZXR1cm4gYSA8IGI7XHJcbn0pO1xyXG5cclxuTlVMTFBUUlxyXG4tLS0tLS0tXHJcbmludCogcHRyID0gbnVsbHB0cjsgIC8vIGluc3RlYWQgb2YgTlVMTFxyXG5cclxuSU5JVElBTElaRVIgTElTVFNcclxuLS0tLS0tLS0tLS0tLS0tLS1cclxudmVjdG9yPGludD4gdiA9IHsxLCAyLCAzLCA0fTtcclxubWFwPHN0cmluZywgaW50PiBtID0ge3tcImFcIiwgMX0sIHtcImJcIiwgMn19O2BcclxuICB9O1xyXG4gIFxyXG4gIHJldHVybiBzaGVldHNbc2hlZXROYW1lXSB8fCBgIyAke3NoZWV0TmFtZX1cXG5cXG5Db250ZW50IGhlcmUuLi5cXG5gO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgWklQIGZpbGUgY29udGVudCAoc2ltcGxpZmllZCAtIGNyZWF0ZXMgYSB0ZXh0IHJlcHJlc2VudGF0aW9uKVxyXG4gKiBOb3RlOiBGb3IgYWN0dWFsIFpJUCBmaWxlcywgeW91J2QgbmVlZCBhIGxpYnJhcnkgbGlrZSBKU1ppcFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWmlwQ29udGVudChpdGVtczogc3RyaW5nW10pOiBzdHJpbmcge1xyXG4gIHJldHVybiBpdGVtcy5qb2luKCdcXG5cXG4tLS1GSUxFIFNFUEFSQVRPUi0tLVxcblxcbicpO1xyXG59XHJcblxyXG4vKipcclxuICogRG93bmxvYWRzIGEgY2hlYXQgc2hlZXQgYXMgUERGICh0ZXh0LWJhc2VkIGZvciBub3cpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRDaGVhdFNoZWV0KHNoZWV0TmFtZTogc3RyaW5nKSB7XHJcbiAgY29uc3QgY29udGVudCA9IGdlbmVyYXRlQ2hlYXRTaGVldENvbnRlbnQoc2hlZXROYW1lKTtcclxuICBkb3dubG9hZEZpbGUoe1xyXG4gICAgbmFtZTogYCR7c2hlZXROYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX0udHh0YCxcclxuICAgIHR5cGU6ICdQREYnLFxyXG4gICAgY29udGVudDogY29udGVudFxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRG93bmxvYWRzIGEgY29kZSB0ZW1wbGF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkQ29kZVRlbXBsYXRlKHRlbXBsYXRlTmFtZTogc3RyaW5nKSB7XHJcbiAgY29uc3QgY29udGVudCA9IGdlbmVyYXRlQ29kZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSk7XHJcbiAgZG93bmxvYWRGaWxlKHtcclxuICAgIG5hbWU6IGAke3RlbXBsYXRlTmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9LmNwcGAsXHJcbiAgICB0eXBlOiAnQ1BQJyxcclxuICAgIGNvbnRlbnQ6IGNvbnRlbnRcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvd25sb2FkcyBjb3Vyc2UgY29kZSBleGFtcGxlcyBhcyBaSVBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZENvdXJzZUNvZGUoY291cnNlVGl0bGU6IHN0cmluZywgbGVzc29uczogYW55W10pIHtcclxuICBjb25zdCBjb2RlRmlsZXMgPSBsZXNzb25zXHJcbiAgICAuZmlsdGVyKGxlc3NvbiA9PiBsZXNzb24uY29kZUV4YW1wbGUpXHJcbiAgICAubWFwKChsZXNzb24sIGluZGV4KSA9PiBgLy8gJHtsZXNzb24udGl0bGV9XFxuJHtsZXNzb24uY29kZUV4YW1wbGV9XFxuYCk7XHJcbiAgXHJcbiAgY29uc3QgY29udGVudCA9IGNvZGVGaWxlcy5qb2luKCdcXG5cXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbicpO1xyXG4gIGRvd25sb2FkRmlsZSh7XHJcbiAgICBuYW1lOiBgJHtjb3Vyc2VUaXRsZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X0NvZGVfRXhhbXBsZXMudHh0YCxcclxuICAgIHR5cGU6ICdaSVAnLFxyXG4gICAgY29udGVudDogY29udGVudFxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRG93bmxvYWRzIHByb2plY3Qgc3RhcnRlciBjb2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRQcm9qZWN0U3RhcnRlckNvZGUocHJvamVjdFRpdGxlOiBzdHJpbmcsIHN0YXJ0ZXJDb2RlPzogc3RyaW5nKSB7XHJcbiAgLy8gRXNjYXBlIHF1b3RlcyBpbiBwcm9qZWN0IHRpdGxlIGZvciBDKysgc3RyaW5nIGxpdGVyYWxcclxuICBjb25zdCBlc2NhcGVkVGl0bGUgPSBwcm9qZWN0VGl0bGUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xyXG4gIGNvbnN0IGNvZGUgPSBzdGFydGVyQ29kZSB8fCBgLy8gJHtwcm9qZWN0VGl0bGV9IFN0YXJ0ZXIgQ29kZVxyXG4jaW5jbHVkZSA8aW9zdHJlYW0+XHJcbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XHJcblxyXG5pbnQgbWFpbigpIHtcclxuICAgIC8vIFlvdXIgY29kZSBoZXJlXHJcbiAgICBjb3V0IDw8IFwiSGVsbG8sICR7ZXNjYXBlZFRpdGxlfSFcIiA8PCBlbmRsO1xyXG4gICAgcmV0dXJuIDA7XHJcbn1gO1xyXG4gIFxyXG4gIGRvd25sb2FkRmlsZSh7XHJcbiAgICBuYW1lOiBgJHtwcm9qZWN0VGl0bGUucmVwbGFjZSgvXFxzKy9nLCAnXycpfV9zdGFydGVyLmNwcGAsXHJcbiAgICB0eXBlOiAnQ1BQJyxcclxuICAgIGNvbnRlbnQ6IGNvZGVcclxuICB9KTtcclxufVxyXG4iXSwibmFtZXMiOlsiZG93bmxvYWRGaWxlIiwiZmlsZSIsImJsb2IiLCJjb250ZW50IiwiQmxvYiIsInR5cGUiLCJnZXRNaW1lVHlwZSIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJuYW1lIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsIm1pbWVUeXBlcyIsInRvVXBwZXJDYXNlIiwiZ2VuZXJhdGVDb2RlVGVtcGxhdGUiLCJ0ZW1wbGF0ZU5hbWUiLCJ0ZW1wbGF0ZXMiLCJnZW5lcmF0ZUNoZWF0U2hlZXRDb250ZW50Iiwic2hlZXROYW1lIiwic2hlZXRzIiwiZ2VuZXJhdGVaaXBDb250ZW50IiwiaXRlbXMiLCJqb2luIiwiZG93bmxvYWRDaGVhdFNoZWV0IiwicmVwbGFjZSIsImRvd25sb2FkQ29kZVRlbXBsYXRlIiwiZG93bmxvYWRDb3Vyc2VDb2RlIiwiY291cnNlVGl0bGUiLCJsZXNzb25zIiwiY29kZUZpbGVzIiwiZmlsdGVyIiwibGVzc29uIiwiY29kZUV4YW1wbGUiLCJtYXAiLCJpbmRleCIsInRpdGxlIiwiZG93bmxvYWRQcm9qZWN0U3RhcnRlckNvZGUiLCJwcm9qZWN0VGl0bGUiLCJzdGFydGVyQ29kZSIsImVzY2FwZWRUaXRsZSIsImNvZGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/downloadUtils.ts\n"));

/***/ })

});