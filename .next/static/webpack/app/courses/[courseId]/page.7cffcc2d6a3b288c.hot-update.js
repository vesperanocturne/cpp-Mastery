"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/courses/[courseId]/page",{

/***/ "(app-pages-browser)/./src/lib/downloadUtils.ts":
/*!**********************************!*\
  !*** ./src/lib/downloadUtils.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadCheatSheet: () => (/* binding */ downloadCheatSheet),\n/* harmony export */   downloadCodeTemplate: () => (/* binding */ downloadCodeTemplate),\n/* harmony export */   downloadCourseCode: () => (/* binding */ downloadCourseCode),\n/* harmony export */   downloadFile: () => (/* binding */ downloadFile),\n/* harmony export */   downloadProjectStarterCode: () => (/* binding */ downloadProjectStarterCode),\n/* harmony export */   generateCheatSheetContent: () => (/* binding */ generateCheatSheetContent),\n/* harmony export */   generateCodeTemplate: () => (/* binding */ generateCodeTemplate),\n/* harmony export */   generateZipContent: () => (/* binding */ generateZipContent)\n/* harmony export */ });\n// Utility functions for generating and downloading files\n/**\r\n * Downloads a file to the user's computer\r\n */ function downloadFile(file) {\n    const blob = file.content instanceof Blob ? file.content : new Blob([\n        file.content\n    ], {\n        type: getMimeType(file.type)\n    });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = file.name;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n}\n/**\r\n * Gets MIME type based on file extension\r\n */ function getMimeType(type) {\n    const mimeTypes = {\n        'PDF': 'application/pdf',\n        'CPP': 'text/plain',\n        'ZIP': 'application/zip',\n        'HTML': 'text/html',\n        'TXT': 'text/plain'\n    };\n    return mimeTypes[type.toUpperCase()] || 'application/octet-stream';\n}\n/**\r\n * Generates a C++ code template based on the template name\r\n */ function generateCodeTemplate(templateName) {\n    const templates = {\n        'Class Template Boilerplate': '#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nclass MyClass {\\nprivate:\\n    // Private member variables\\n    string name;\\n    int value;\\n\\npublic:\\n    // Constructor\\n    MyClass(string n, int v) : name(n), value(v) {}\\n    \\n    // Destructor\\n    ~MyClass() {\\n        cout << \"Object destroyed\" << endl;\\n    }\\n    \\n    // Getter methods\\n    string getName() const { return name; }\\n    int getValue() const { return value; }\\n    \\n    // Setter methods\\n    void setName(string n) { name = n; }\\n    void setValue(int v) { value = v; }\\n    \\n    // Member function\\n    void display() const {\\n        cout << \"Name: \" << name << \", Value: \" << value << endl;\\n    }\\n};\\n\\nint main() {\\n    MyClass obj(\"Example\", 42);\\n    obj.display();\\n    return 0;\\n}',\n        'Algorithm Templates': '#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\n// Binary Search Template\\nint binarySearch(vector<int>& arr, int target) {\\n    int left = 0, right = arr.size() - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (arr[mid] == target) return mid;\\n        if (arr[mid] < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n    return -1;\\n}\\n\\n// Quick Sort Template\\nvoid quickSort(vector<int>& arr, int low, int high) {\\n    if (low < high) {\\n        int pivot = arr[high];\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (arr[j] < pivot) {\\n                i++;\\n                swap(arr[i], arr[j]);\\n            }\\n        }\\n        swap(arr[i + 1], arr[high]);\\n        int pi = i + 1;\\n        quickSort(arr, low, pi - 1);\\n        quickSort(arr, pi + 1, high);\\n    }\\n}\\n\\nint main() {\\n    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};\\n    quickSort(arr, 0, arr.size() - 1);\\n    for (int x : arr) cout << x << \" \";\\n    return 0;\\n}',\n        'Data Structure Templates': \"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <stack>\\nusing namespace std;\\n\\n// Linked List Node\\nstruct ListNode {\\n    int val;\\n    ListNode* next;\\n    ListNode(int x) : val(x), next(nullptr) {}\\n};\\n\\n// Binary Tree Node\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n};\\n\\n// Stack Implementation\\nclass MyStack {\\nprivate:\\n    vector<int> data;\\npublic:\\n    void push(int x) { data.push_back(x); }\\n    void pop() { data.pop_back(); }\\n    int top() { return data.back(); }\\n    bool empty() { return data.empty(); }\\n};\\n\\n// Queue Implementation\\nclass MyQueue {\\nprivate:\\n    vector<int> data;\\npublic:\\n    void enqueue(int x) { data.push_back(x); }\\n    void dequeue() { data.erase(data.begin()); }\\n    int front() { return data.front(); }\\n    bool empty() { return data.empty(); }\\n};\\n\\nint main() {\\n    MyStack s;\\n    s.push(1);\\n    s.push(2);\\n    cout << s.top() << endl;\\n    return 0;\\n}\"\n    };\n    return templates[templateName] || \"// \".concat(templateName, \"\\n// Template code here\\n\");\n}\n/**\r\n * Generates a PDF-like text content for cheat sheets\r\n */ function generateCheatSheetContent(sheetName) {\n    const sheets = {\n        'Basic Syntax Cheat Sheet': \"C++ BASIC SYNTAX CHEAT SHEET\\n=====================================\\n\\nVARIABLES & DATA TYPES\\n----------------------\\nint age = 25;\\nfloat height = 5.9f;\\ndouble salary = 50000.50;\\nchar grade = 'A';\\nbool isStudent = true;\\nstring name = \\\"John\\\";\\n\\nCONTROL FLOW\\n------------\\nif (condition) { }\\nelse if (condition) { }\\nelse { }\\n\\nfor (int i = 0; i < n; i++) { }\\nwhile (condition) { }\\ndo { } while (condition);\\n\\nswitch (value) {\\n    case 1: break;\\n    default: break;\\n}\\n\\nFUNCTIONS\\n---------\\nreturnType functionName(params) {\\n    return value;\\n}\\n\\nvoid functionName() { }\\n\\nCLASSES\\n-------\\nclass ClassName {\\nprivate:\\n    int privateVar;\\npublic:\\n    ClassName() { }\\n    ~ClassName() { }\\n    void method() { }\\n};\\n\\nPOINTERS & REFERENCES\\n---------------------\\nint* ptr = &variable;\\nint& ref = variable;\\n*ptr = value;\\n\\nSTANDARD LIBRARY\\n----------------\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\",\n        'STL Containers Reference': 'C++ STL CONTAINERS REFERENCE\\n=============================\\n\\nVECTOR\\n------\\nvector<int> v;\\nv.push_back(10);\\nv.pop_back();\\nv.size();\\nv.empty();\\nv[i];\\n\\nLIST\\n----\\nlist<int> l;\\nl.push_back(10);\\nl.push_front(5);\\nl.pop_back();\\nl.pop_front();\\n\\nMAP\\n---\\nmap<string, int> m;\\nm[\"key\"] = value;\\nm.find(\"key\");\\nm.erase(\"key\");\\n\\nSET\\n---\\nset<int> s;\\ns.insert(10);\\ns.find(10);\\ns.erase(10);\\n\\nQUEUE\\n-----\\nqueue<int> q;\\nq.push(10);\\nq.pop();\\nq.front();\\nq.empty();\\n\\nSTACK\\n-----\\nstack<int> s;\\ns.push(10);\\ns.pop();\\ns.top();\\ns.empty();',\n        'OOP Concepts Guide': \"C++ OBJECT-ORIENTED PROGRAMMING GUIDE\\n=====================================\\n\\nENCAPSULATION\\n-------------\\n- Private members: Only accessible within class\\n- Protected members: Accessible in class and derived classes\\n- Public members: Accessible everywhere\\n\\nINHERITANCE\\n-----------\\nclass Base {\\n    // base class members\\n};\\n\\nclass Derived : public Base {\\n    // derived class members\\n};\\n\\nPOLYMORPHISM\\n------------\\n- Function Overriding: Redefine base class function\\n- Virtual Functions: Enable runtime polymorphism\\n- Abstract Classes: Classes with pure virtual functions\\n\\nABSTRACTION\\n-----------\\n- Hide implementation details\\n- Show only essential features\\n- Use abstract classes and interfaces\\n\\nKEYWORDS\\n--------\\nvirtual: Enable polymorphism\\noverride: Explicitly override base function\\nfinal: Prevent further overriding\\nabstract: Pure virtual functions\",\n        'Modern C++ Features': 'MODERN C++ FEATURES (C++11/14/17/20)\\n====================================\\n\\nAUTO KEYWORD\\n------------\\nauto x = 10;\\nauto name = \"C++\";\\n\\nRANGE-BASED FOR LOOP\\n--------------------\\nfor (auto& item : container) {\\n    // process item\\n}\\n\\nSMART POINTERS\\n--------------\\nunique_ptr<T> ptr = make_unique<T>();\\nshared_ptr<T> ptr = make_shared<T>();\\nweak_ptr<T> ptr;\\n\\nLAMBDA EXPRESSIONS\\n------------------\\nauto lambda = [](int x) { return x * 2; };\\nsort(v.begin(), v.end(), [](int a, int b) {\\n    return a < b;\\n});\\n\\nNULLPTR\\n-------\\nint* ptr = nullptr;  // instead of NULL\\n\\nINITIALIZER LISTS\\n-----------------\\nvector<int> v = {1, 2, 3, 4};\\nmap<string, int> m = {{\"a\", 1}, {\"b\", 2}};'\n    };\n    return sheets[sheetName] || \"# \".concat(sheetName, \"\\n\\nContent here...\\n\");\n}\n/**\r\n * Generates a ZIP file content (simplified - creates a text representation)\r\n * Note: For actual ZIP files, you'd need a library like JSZip\r\n */ function generateZipContent(items) {\n    return items.join('\\n\\n---FILE SEPARATOR---\\n\\n');\n}\n/**\r\n * Downloads a cheat sheet as PDF (text-based for now)\r\n */ function downloadCheatSheet(sheetName) {\n    const content = generateCheatSheetContent(sheetName);\n    downloadFile({\n        name: \"\".concat(sheetName.replace(/\\s+/g, '_'), \".txt\"),\n        type: 'PDF',\n        content: content\n    });\n}\n/**\r\n * Downloads a code template\r\n */ function downloadCodeTemplate(templateName) {\n    const content = generateCodeTemplate(templateName);\n    downloadFile({\n        name: \"\".concat(templateName.replace(/\\s+/g, '_'), \".cpp\"),\n        type: 'CPP',\n        content: content\n    });\n}\n/**\r\n * Downloads course code examples as ZIP\r\n */ function downloadCourseCode(courseTitle, lessons) {\n    const codeFiles = lessons.filter((lesson)=>lesson.codeExample).map((lesson, index)=>\"// \".concat(lesson.title, \"\\n\").concat(lesson.codeExample, \"\\n\"));\n    const content = codeFiles.join('\\n\\n// ============================================\\n\\n');\n    downloadFile({\n        name: \"\".concat(courseTitle.replace(/\\s+/g, '_'), \"_Code_Examples.txt\"),\n        type: 'ZIP',\n        content: content\n    });\n}\n/**\r\n * Downloads project starter code\r\n */ function downloadProjectStarterCode(projectTitle, starterCode) {\n    const code = starterCode || \"// \".concat(projectTitle, ' Starter Code\\n#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    // Your code here\\n    cout << \"Hello, ').concat(projectTitle.replace(/\"/g, '\\\\\"'), '!\" << endl;\\n    return 0;\\n}');\n    downloadFile({\n        name: \"\".concat(projectTitle.replace(/\\s+/g, '_'), \"_starter.cpp\"),\n        type: 'CPP',\n        content: code\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG93bmxvYWRVdGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHlEQUF5RDtBQVF6RDs7Q0FFQyxHQUNNLFNBQVNBLGFBQWFDLElBQWtCO0lBQzdDLE1BQU1DLE9BQU9ELEtBQUtFLE9BQU8sWUFBWUMsT0FDakNILEtBQUtFLE9BQU8sR0FDWixJQUFJQyxLQUFLO1FBQUNILEtBQUtFLE9BQU87S0FBQyxFQUFFO1FBQUVFLE1BQU1DLFlBQVlMLEtBQUtJLElBQUk7SUFBRTtJQUU1RCxNQUFNRSxNQUFNQyxJQUFJQyxlQUFlLENBQUNQO0lBQ2hDLE1BQU1RLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztJQUNwQ0YsS0FBS0csSUFBSSxHQUFHTjtJQUNaRyxLQUFLSSxRQUFRLEdBQUdiLEtBQUtjLElBQUk7SUFDekJKLFNBQVNLLElBQUksQ0FBQ0MsV0FBVyxDQUFDUDtJQUMxQkEsS0FBS1EsS0FBSztJQUNWUCxTQUFTSyxJQUFJLENBQUNHLFdBQVcsQ0FBQ1Q7SUFDMUJGLElBQUlZLGVBQWUsQ0FBQ2I7QUFDdEI7QUFFQTs7Q0FFQyxHQUNELFNBQVNELFlBQVlELElBQVk7SUFDL0IsTUFBTWdCLFlBQW9DO1FBQ3hDLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUNQLFFBQVE7UUFDUixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxTQUFTLENBQUNoQixLQUFLaUIsV0FBVyxHQUFHLElBQUk7QUFDMUM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLHFCQUFxQkMsWUFBb0I7SUFDdkQsTUFBTUMsWUFBb0M7UUFDeEMsOEJBQStCO1FBc0MvQix1QkFBd0I7UUF5Q3hCLDRCQUE2QjtJQWtEL0I7SUFFQSxPQUFPQSxTQUFTLENBQUNELGFBQWEsSUFBSSxNQUFtQixPQUFiQSxjQUFhO0FBQ3ZEO0FBRUE7O0NBRUMsR0FDTSxTQUFTRSwwQkFBMEJDLFNBQWlCO0lBQ3pELE1BQU1DLFNBQWlDO1FBQ3JDLDRCQUE2QjtRQTJEN0IsNEJBQTZCO1FBaUQ3QixzQkFBdUI7UUFxQ3ZCLHVCQUF3QjtJQW1DMUI7SUFFQSxPQUFPQSxNQUFNLENBQUNELFVBQVUsSUFBSSxLQUFlLE9BQVZBLFdBQVU7QUFDN0M7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRSxtQkFBbUJDLEtBQWU7SUFDaEQsT0FBT0EsTUFBTUMsSUFBSSxDQUFDO0FBQ3BCO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxtQkFBbUJMLFNBQWlCO0lBQ2xELE1BQU14QixVQUFVdUIsMEJBQTBCQztJQUMxQzNCLGFBQWE7UUFDWGUsTUFBTSxHQUFrQyxPQUEvQlksVUFBVU0sT0FBTyxDQUFDLFFBQVEsTUFBSztRQUN4QzVCLE1BQU07UUFDTkYsU0FBU0E7SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTK0IscUJBQXFCVixZQUFvQjtJQUN2RCxNQUFNckIsVUFBVW9CLHFCQUFxQkM7SUFDckN4QixhQUFhO1FBQ1hlLE1BQU0sR0FBcUMsT0FBbENTLGFBQWFTLE9BQU8sQ0FBQyxRQUFRLE1BQUs7UUFDM0M1QixNQUFNO1FBQ05GLFNBQVNBO0lBQ1g7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU2dDLG1CQUFtQkMsV0FBbUIsRUFBRUMsT0FBYztJQUNwRSxNQUFNQyxZQUFZRCxRQUNmRSxNQUFNLENBQUNDLENBQUFBLFNBQVVBLE9BQU9DLFdBQVcsRUFDbkNDLEdBQUcsQ0FBQyxDQUFDRixRQUFRRyxRQUFVLE1BQXVCSCxPQUFqQkEsT0FBT0ksS0FBSyxFQUFDLE1BQXVCLE9BQW5CSixPQUFPQyxXQUFXLEVBQUM7SUFFcEUsTUFBTXRDLFVBQVVtQyxVQUFVUCxJQUFJLENBQUM7SUFDL0IvQixhQUFhO1FBQ1hlLE1BQU0sR0FBb0MsT0FBakNxQixZQUFZSCxPQUFPLENBQUMsUUFBUSxNQUFLO1FBQzFDNUIsTUFBTTtRQUNORixTQUFTQTtJQUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVMwQywyQkFBMkJDLFlBQW9CLEVBQUVDLFdBQW9CO0lBQ25GLE1BQU1DLE9BQU9ELGVBQWUsTUFNUkQsT0FOY0EsY0FBYSx5SEFNTyxPQUFsQ0EsYUFBYWIsT0FBTyxDQUFDLE1BQU0sUUFBTztJQUl0RGpDLGFBQWE7UUFDWGUsTUFBTSxHQUFxQyxPQUFsQytCLGFBQWFiLE9BQU8sQ0FBQyxRQUFRLE1BQUs7UUFDM0M1QixNQUFNO1FBQ05GLFNBQVM2QztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccHJpeWFcXE9uZURyaXZlXFxEb2N1bWVudHNcXEdpdEh1YlxcY3BwLU1hc3RlcnlcXHNyY1xcbGliXFxkb3dubG9hZFV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBnZW5lcmF0aW5nIGFuZCBkb3dubG9hZGluZyBmaWxlc1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEb3dubG9hZEZpbGUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICB0eXBlOiBzdHJpbmc7XHJcbiAgY29udGVudDogc3RyaW5nIHwgQmxvYjtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvd25sb2FkcyBhIGZpbGUgdG8gdGhlIHVzZXIncyBjb21wdXRlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlOiBEb3dubG9hZEZpbGUpIHtcclxuICBjb25zdCBibG9iID0gZmlsZS5jb250ZW50IGluc3RhbmNlb2YgQmxvYiBcclxuICAgID8gZmlsZS5jb250ZW50IFxyXG4gICAgOiBuZXcgQmxvYihbZmlsZS5jb250ZW50XSwgeyB0eXBlOiBnZXRNaW1lVHlwZShmaWxlLnR5cGUpIH0pO1xyXG4gIFxyXG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICBsaW5rLmhyZWYgPSB1cmw7XHJcbiAgbGluay5kb3dubG9hZCA9IGZpbGUubmFtZTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG4gIGxpbmsuY2xpY2soKTtcclxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG4gIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgTUlNRSB0eXBlIGJhc2VkIG9uIGZpbGUgZXh0ZW5zaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW1lVHlwZSh0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IG1pbWVUeXBlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICdQREYnOiAnYXBwbGljYXRpb24vcGRmJyxcclxuICAgICdDUFAnOiAndGV4dC9wbGFpbicsXHJcbiAgICAnWklQJzogJ2FwcGxpY2F0aW9uL3ppcCcsXHJcbiAgICAnSFRNTCc6ICd0ZXh0L2h0bWwnLFxyXG4gICAgJ1RYVCc6ICd0ZXh0L3BsYWluJ1xyXG4gIH07XHJcbiAgcmV0dXJuIG1pbWVUeXBlc1t0eXBlLnRvVXBwZXJDYXNlKCldIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgQysrIGNvZGUgdGVtcGxhdGUgYmFzZWQgb24gdGhlIHRlbXBsYXRlIG5hbWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNvZGVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgdGVtcGxhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgJ0NsYXNzIFRlbXBsYXRlIEJvaWxlcnBsYXRlJzogYCNpbmNsdWRlIDxpb3N0cmVhbT5cclxuI2luY2x1ZGUgPHN0cmluZz5cclxudXNpbmcgbmFtZXNwYWNlIHN0ZDtcclxuXHJcbmNsYXNzIE15Q2xhc3Mge1xyXG5wcml2YXRlOlxyXG4gICAgLy8gUHJpdmF0ZSBtZW1iZXIgdmFyaWFibGVzXHJcbiAgICBzdHJpbmcgbmFtZTtcclxuICAgIGludCB2YWx1ZTtcclxuXHJcbnB1YmxpYzpcclxuICAgIC8vIENvbnN0cnVjdG9yXHJcbiAgICBNeUNsYXNzKHN0cmluZyBuLCBpbnQgdikgOiBuYW1lKG4pLCB2YWx1ZSh2KSB7fVxyXG4gICAgXHJcbiAgICAvLyBEZXN0cnVjdG9yXHJcbiAgICB+TXlDbGFzcygpIHtcclxuICAgICAgICBjb3V0IDw8IFwiT2JqZWN0IGRlc3Ryb3llZFwiIDw8IGVuZGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEdldHRlciBtZXRob2RzXHJcbiAgICBzdHJpbmcgZ2V0TmFtZSgpIGNvbnN0IHsgcmV0dXJuIG5hbWU7IH1cclxuICAgIGludCBnZXRWYWx1ZSgpIGNvbnN0IHsgcmV0dXJuIHZhbHVlOyB9XHJcbiAgICBcclxuICAgIC8vIFNldHRlciBtZXRob2RzXHJcbiAgICB2b2lkIHNldE5hbWUoc3RyaW5nIG4pIHsgbmFtZSA9IG47IH1cclxuICAgIHZvaWQgc2V0VmFsdWUoaW50IHYpIHsgdmFsdWUgPSB2OyB9XHJcbiAgICBcclxuICAgIC8vIE1lbWJlciBmdW5jdGlvblxyXG4gICAgdm9pZCBkaXNwbGF5KCkgY29uc3Qge1xyXG4gICAgICAgIGNvdXQgPDwgXCJOYW1lOiBcIiA8PCBuYW1lIDw8IFwiLCBWYWx1ZTogXCIgPDwgdmFsdWUgPDwgZW5kbDtcclxuICAgIH1cclxufTtcclxuXHJcbmludCBtYWluKCkge1xyXG4gICAgTXlDbGFzcyBvYmooXCJFeGFtcGxlXCIsIDQyKTtcclxuICAgIG9iai5kaXNwbGF5KCk7XHJcbiAgICByZXR1cm4gMDtcclxufWAsXHJcbiAgICAnQWxnb3JpdGhtIFRlbXBsYXRlcyc6IGAjaW5jbHVkZSA8aW9zdHJlYW0+XHJcbiNpbmNsdWRlIDx2ZWN0b3I+XHJcbiNpbmNsdWRlIDxhbGdvcml0aG0+XHJcbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XHJcblxyXG4vLyBCaW5hcnkgU2VhcmNoIFRlbXBsYXRlXHJcbmludCBiaW5hcnlTZWFyY2godmVjdG9yPGludD4mIGFyciwgaW50IHRhcmdldCkge1xyXG4gICAgaW50IGxlZnQgPSAwLCByaWdodCA9IGFyci5zaXplKCkgLSAxO1xyXG4gICAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcclxuICAgICAgICBpbnQgbWlkID0gbGVmdCArIChyaWdodCAtIGxlZnQpIC8gMjtcclxuICAgICAgICBpZiAoYXJyW21pZF0gPT0gdGFyZ2V0KSByZXR1cm4gbWlkO1xyXG4gICAgICAgIGlmIChhcnJbbWlkXSA8IHRhcmdldCkgbGVmdCA9IG1pZCArIDE7XHJcbiAgICAgICAgZWxzZSByaWdodCA9IG1pZCAtIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIFF1aWNrIFNvcnQgVGVtcGxhdGVcclxudm9pZCBxdWlja1NvcnQodmVjdG9yPGludD4mIGFyciwgaW50IGxvdywgaW50IGhpZ2gpIHtcclxuICAgIGlmIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgICAgaW50IHBpdm90ID0gYXJyW2hpZ2hdO1xyXG4gICAgICAgIGludCBpID0gbG93IC0gMTtcclxuICAgICAgICBmb3IgKGludCBqID0gbG93OyBqIDwgaGlnaDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBwaXZvdCkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgc3dhcChhcnJbaV0sIGFycltqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3dhcChhcnJbaSArIDFdLCBhcnJbaGlnaF0pO1xyXG4gICAgICAgIGludCBwaSA9IGkgKyAxO1xyXG4gICAgICAgIHF1aWNrU29ydChhcnIsIGxvdywgcGkgLSAxKTtcclxuICAgICAgICBxdWlja1NvcnQoYXJyLCBwaSArIDEsIGhpZ2gpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnQgbWFpbigpIHtcclxuICAgIHZlY3RvcjxpbnQ+IGFyciA9IHs2NCwgMzQsIDI1LCAxMiwgMjIsIDExLCA5MH07XHJcbiAgICBxdWlja1NvcnQoYXJyLCAwLCBhcnIuc2l6ZSgpIC0gMSk7XHJcbiAgICBmb3IgKGludCB4IDogYXJyKSBjb3V0IDw8IHggPDwgXCIgXCI7XHJcbiAgICByZXR1cm4gMDtcclxufWAsXHJcbiAgICAnRGF0YSBTdHJ1Y3R1cmUgVGVtcGxhdGVzJzogYCNpbmNsdWRlIDxpb3N0cmVhbT5cclxuI2luY2x1ZGUgPHZlY3Rvcj5cclxuI2luY2x1ZGUgPHF1ZXVlPlxyXG4jaW5jbHVkZSA8c3RhY2s+XHJcbnVzaW5nIG5hbWVzcGFjZSBzdGQ7XHJcblxyXG4vLyBMaW5rZWQgTGlzdCBOb2RlXHJcbnN0cnVjdCBMaXN0Tm9kZSB7XHJcbiAgICBpbnQgdmFsO1xyXG4gICAgTGlzdE5vZGUqIG5leHQ7XHJcbiAgICBMaXN0Tm9kZShpbnQgeCkgOiB2YWwoeCksIG5leHQobnVsbHB0cikge31cclxufTtcclxuXHJcbi8vIEJpbmFyeSBUcmVlIE5vZGVcclxuc3RydWN0IFRyZWVOb2RlIHtcclxuICAgIGludCB2YWw7XHJcbiAgICBUcmVlTm9kZSogbGVmdDtcclxuICAgIFRyZWVOb2RlKiByaWdodDtcclxuICAgIFRyZWVOb2RlKGludCB4KSA6IHZhbCh4KSwgbGVmdChudWxscHRyKSwgcmlnaHQobnVsbHB0cikge31cclxufTtcclxuXHJcbi8vIFN0YWNrIEltcGxlbWVudGF0aW9uXHJcbmNsYXNzIE15U3RhY2sge1xyXG5wcml2YXRlOlxyXG4gICAgdmVjdG9yPGludD4gZGF0YTtcclxucHVibGljOlxyXG4gICAgdm9pZCBwdXNoKGludCB4KSB7IGRhdGEucHVzaF9iYWNrKHgpOyB9XHJcbiAgICB2b2lkIHBvcCgpIHsgZGF0YS5wb3BfYmFjaygpOyB9XHJcbiAgICBpbnQgdG9wKCkgeyByZXR1cm4gZGF0YS5iYWNrKCk7IH1cclxuICAgIGJvb2wgZW1wdHkoKSB7IHJldHVybiBkYXRhLmVtcHR5KCk7IH1cclxufTtcclxuXHJcbi8vIFF1ZXVlIEltcGxlbWVudGF0aW9uXHJcbmNsYXNzIE15UXVldWUge1xyXG5wcml2YXRlOlxyXG4gICAgdmVjdG9yPGludD4gZGF0YTtcclxucHVibGljOlxyXG4gICAgdm9pZCBlbnF1ZXVlKGludCB4KSB7IGRhdGEucHVzaF9iYWNrKHgpOyB9XHJcbiAgICB2b2lkIGRlcXVldWUoKSB7IGRhdGEuZXJhc2UoZGF0YS5iZWdpbigpKTsgfVxyXG4gICAgaW50IGZyb250KCkgeyByZXR1cm4gZGF0YS5mcm9udCgpOyB9XHJcbiAgICBib29sIGVtcHR5KCkgeyByZXR1cm4gZGF0YS5lbXB0eSgpOyB9XHJcbn07XHJcblxyXG5pbnQgbWFpbigpIHtcclxuICAgIE15U3RhY2sgcztcclxuICAgIHMucHVzaCgxKTtcclxuICAgIHMucHVzaCgyKTtcclxuICAgIGNvdXQgPDwgcy50b3AoKSA8PCBlbmRsO1xyXG4gICAgcmV0dXJuIDA7XHJcbn1gXHJcbiAgfTtcclxuICBcclxuICByZXR1cm4gdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gfHwgYC8vICR7dGVtcGxhdGVOYW1lfVxcbi8vIFRlbXBsYXRlIGNvZGUgaGVyZVxcbmA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBQREYtbGlrZSB0ZXh0IGNvbnRlbnQgZm9yIGNoZWF0IHNoZWV0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2hlYXRTaGVldENvbnRlbnQoc2hlZXROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGNvbnN0IHNoZWV0czogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICdCYXNpYyBTeW50YXggQ2hlYXQgU2hlZXQnOiBgQysrIEJBU0lDIFNZTlRBWCBDSEVBVCBTSEVFVFxyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5WQVJJQUJMRVMgJiBEQVRBIFRZUEVTXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuaW50IGFnZSA9IDI1O1xyXG5mbG9hdCBoZWlnaHQgPSA1LjlmO1xyXG5kb3VibGUgc2FsYXJ5ID0gNTAwMDAuNTA7XHJcbmNoYXIgZ3JhZGUgPSAnQSc7XHJcbmJvb2wgaXNTdHVkZW50ID0gdHJ1ZTtcclxuc3RyaW5nIG5hbWUgPSBcIkpvaG5cIjtcclxuXHJcbkNPTlRST0wgRkxPV1xyXG4tLS0tLS0tLS0tLS1cclxuaWYgKGNvbmRpdGlvbikgeyB9XHJcbmVsc2UgaWYgKGNvbmRpdGlvbikgeyB9XHJcbmVsc2UgeyB9XHJcblxyXG5mb3IgKGludCBpID0gMDsgaSA8IG47IGkrKykgeyB9XHJcbndoaWxlIChjb25kaXRpb24pIHsgfVxyXG5kbyB7IH0gd2hpbGUgKGNvbmRpdGlvbik7XHJcblxyXG5zd2l0Y2ggKHZhbHVlKSB7XHJcbiAgICBjYXNlIDE6IGJyZWFrO1xyXG4gICAgZGVmYXVsdDogYnJlYWs7XHJcbn1cclxuXHJcbkZVTkNUSU9OU1xyXG4tLS0tLS0tLS1cclxucmV0dXJuVHlwZSBmdW5jdGlvbk5hbWUocGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbnZvaWQgZnVuY3Rpb25OYW1lKCkgeyB9XHJcblxyXG5DTEFTU0VTXHJcbi0tLS0tLS1cclxuY2xhc3MgQ2xhc3NOYW1lIHtcclxucHJpdmF0ZTpcclxuICAgIGludCBwcml2YXRlVmFyO1xyXG5wdWJsaWM6XHJcbiAgICBDbGFzc05hbWUoKSB7IH1cclxuICAgIH5DbGFzc05hbWUoKSB7IH1cclxuICAgIHZvaWQgbWV0aG9kKCkgeyB9XHJcbn07XHJcblxyXG5QT0lOVEVSUyAmIFJFRkVSRU5DRVNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmludCogcHRyID0gJnZhcmlhYmxlO1xyXG5pbnQmIHJlZiA9IHZhcmlhYmxlO1xyXG4qcHRyID0gdmFsdWU7XHJcblxyXG5TVEFOREFSRCBMSUJSQVJZXHJcbi0tLS0tLS0tLS0tLS0tLS1cclxuI2luY2x1ZGUgPGlvc3RyZWFtPlxyXG4jaW5jbHVkZSA8dmVjdG9yPlxyXG4jaW5jbHVkZSA8c3RyaW5nPlxyXG4jaW5jbHVkZSA8YWxnb3JpdGhtPlxyXG51c2luZyBuYW1lc3BhY2Ugc3RkO2AsXHJcbiAgICAnU1RMIENvbnRhaW5lcnMgUmVmZXJlbmNlJzogYEMrKyBTVEwgQ09OVEFJTkVSUyBSRUZFUkVOQ0VcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblZFQ1RPUlxyXG4tLS0tLS1cclxudmVjdG9yPGludD4gdjtcclxudi5wdXNoX2JhY2soMTApO1xyXG52LnBvcF9iYWNrKCk7XHJcbnYuc2l6ZSgpO1xyXG52LmVtcHR5KCk7XHJcbnZbaV07XHJcblxyXG5MSVNUXHJcbi0tLS1cclxubGlzdDxpbnQ+IGw7XHJcbmwucHVzaF9iYWNrKDEwKTtcclxubC5wdXNoX2Zyb250KDUpO1xyXG5sLnBvcF9iYWNrKCk7XHJcbmwucG9wX2Zyb250KCk7XHJcblxyXG5NQVBcclxuLS0tXHJcbm1hcDxzdHJpbmcsIGludD4gbTtcclxubVtcImtleVwiXSA9IHZhbHVlO1xyXG5tLmZpbmQoXCJrZXlcIik7XHJcbm0uZXJhc2UoXCJrZXlcIik7XHJcblxyXG5TRVRcclxuLS0tXHJcbnNldDxpbnQ+IHM7XHJcbnMuaW5zZXJ0KDEwKTtcclxucy5maW5kKDEwKTtcclxucy5lcmFzZSgxMCk7XHJcblxyXG5RVUVVRVxyXG4tLS0tLVxyXG5xdWV1ZTxpbnQ+IHE7XHJcbnEucHVzaCgxMCk7XHJcbnEucG9wKCk7XHJcbnEuZnJvbnQoKTtcclxucS5lbXB0eSgpO1xyXG5cclxuU1RBQ0tcclxuLS0tLS1cclxuc3RhY2s8aW50PiBzO1xyXG5zLnB1c2goMTApO1xyXG5zLnBvcCgpO1xyXG5zLnRvcCgpO1xyXG5zLmVtcHR5KCk7YCxcclxuICAgICdPT1AgQ29uY2VwdHMgR3VpZGUnOiBgQysrIE9CSkVDVC1PUklFTlRFRCBQUk9HUkFNTUlORyBHVUlERVxyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5FTkNBUFNVTEFUSU9OXHJcbi0tLS0tLS0tLS0tLS1cclxuLSBQcml2YXRlIG1lbWJlcnM6IE9ubHkgYWNjZXNzaWJsZSB3aXRoaW4gY2xhc3NcclxuLSBQcm90ZWN0ZWQgbWVtYmVyczogQWNjZXNzaWJsZSBpbiBjbGFzcyBhbmQgZGVyaXZlZCBjbGFzc2VzXHJcbi0gUHVibGljIG1lbWJlcnM6IEFjY2Vzc2libGUgZXZlcnl3aGVyZVxyXG5cclxuSU5IRVJJVEFOQ0VcclxuLS0tLS0tLS0tLS1cclxuY2xhc3MgQmFzZSB7XHJcbiAgICAvLyBiYXNlIGNsYXNzIG1lbWJlcnNcclxufTtcclxuXHJcbmNsYXNzIERlcml2ZWQgOiBwdWJsaWMgQmFzZSB7XHJcbiAgICAvLyBkZXJpdmVkIGNsYXNzIG1lbWJlcnNcclxufTtcclxuXHJcblBPTFlNT1JQSElTTVxyXG4tLS0tLS0tLS0tLS1cclxuLSBGdW5jdGlvbiBPdmVycmlkaW5nOiBSZWRlZmluZSBiYXNlIGNsYXNzIGZ1bmN0aW9uXHJcbi0gVmlydHVhbCBGdW5jdGlvbnM6IEVuYWJsZSBydW50aW1lIHBvbHltb3JwaGlzbVxyXG4tIEFic3RyYWN0IENsYXNzZXM6IENsYXNzZXMgd2l0aCBwdXJlIHZpcnR1YWwgZnVuY3Rpb25zXHJcblxyXG5BQlNUUkFDVElPTlxyXG4tLS0tLS0tLS0tLVxyXG4tIEhpZGUgaW1wbGVtZW50YXRpb24gZGV0YWlsc1xyXG4tIFNob3cgb25seSBlc3NlbnRpYWwgZmVhdHVyZXNcclxuLSBVc2UgYWJzdHJhY3QgY2xhc3NlcyBhbmQgaW50ZXJmYWNlc1xyXG5cclxuS0VZV09SRFNcclxuLS0tLS0tLS1cclxudmlydHVhbDogRW5hYmxlIHBvbHltb3JwaGlzbVxyXG5vdmVycmlkZTogRXhwbGljaXRseSBvdmVycmlkZSBiYXNlIGZ1bmN0aW9uXHJcbmZpbmFsOiBQcmV2ZW50IGZ1cnRoZXIgb3ZlcnJpZGluZ1xyXG5hYnN0cmFjdDogUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uc2AsXHJcbiAgICAnTW9kZXJuIEMrKyBGZWF0dXJlcyc6IGBNT0RFUk4gQysrIEZFQVRVUkVTIChDKysxMS8xNC8xNy8yMClcclxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5BVVRPIEtFWVdPUkRcclxuLS0tLS0tLS0tLS0tXHJcbmF1dG8geCA9IDEwO1xyXG5hdXRvIG5hbWUgPSBcIkMrK1wiO1xyXG5cclxuUkFOR0UtQkFTRUQgRk9SIExPT1BcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZm9yIChhdXRvJiBpdGVtIDogY29udGFpbmVyKSB7XHJcbiAgICAvLyBwcm9jZXNzIGl0ZW1cclxufVxyXG5cclxuU01BUlQgUE9JTlRFUlNcclxuLS0tLS0tLS0tLS0tLS1cclxudW5pcXVlX3B0cjxUPiBwdHIgPSBtYWtlX3VuaXF1ZTxUPigpO1xyXG5zaGFyZWRfcHRyPFQ+IHB0ciA9IG1ha2Vfc2hhcmVkPFQ+KCk7XHJcbndlYWtfcHRyPFQ+IHB0cjtcclxuXHJcbkxBTUJEQSBFWFBSRVNTSU9OU1xyXG4tLS0tLS0tLS0tLS0tLS0tLS1cclxuYXV0byBsYW1iZGEgPSBbXShpbnQgeCkgeyByZXR1cm4geCAqIDI7IH07XHJcbnNvcnQodi5iZWdpbigpLCB2LmVuZCgpLCBbXShpbnQgYSwgaW50IGIpIHtcclxuICAgIHJldHVybiBhIDwgYjtcclxufSk7XHJcblxyXG5OVUxMUFRSXHJcbi0tLS0tLS1cclxuaW50KiBwdHIgPSBudWxscHRyOyAgLy8gaW5zdGVhZCBvZiBOVUxMXHJcblxyXG5JTklUSUFMSVpFUiBMSVNUU1xyXG4tLS0tLS0tLS0tLS0tLS0tLVxyXG52ZWN0b3I8aW50PiB2ID0gezEsIDIsIDMsIDR9O1xyXG5tYXA8c3RyaW5nLCBpbnQ+IG0gPSB7e1wiYVwiLCAxfSwge1wiYlwiLCAyfX07YFxyXG4gIH07XHJcbiAgXHJcbiAgcmV0dXJuIHNoZWV0c1tzaGVldE5hbWVdIHx8IGAjICR7c2hlZXROYW1lfVxcblxcbkNvbnRlbnQgaGVyZS4uLlxcbmA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBaSVAgZmlsZSBjb250ZW50IChzaW1wbGlmaWVkIC0gY3JlYXRlcyBhIHRleHQgcmVwcmVzZW50YXRpb24pXHJcbiAqIE5vdGU6IEZvciBhY3R1YWwgWklQIGZpbGVzLCB5b3UnZCBuZWVkIGEgbGlicmFyeSBsaWtlIEpTWmlwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVaaXBDb250ZW50KGl0ZW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGl0ZW1zLmpvaW4oJ1xcblxcbi0tLUZJTEUgU0VQQVJBVE9SLS0tXFxuXFxuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb3dubG9hZHMgYSBjaGVhdCBzaGVldCBhcyBQREYgKHRleHQtYmFzZWQgZm9yIG5vdylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZENoZWF0U2hlZXQoc2hlZXROYW1lOiBzdHJpbmcpIHtcclxuICBjb25zdCBjb250ZW50ID0gZ2VuZXJhdGVDaGVhdFNoZWV0Q29udGVudChzaGVldE5hbWUpO1xyXG4gIGRvd25sb2FkRmlsZSh7XHJcbiAgICBuYW1lOiBgJHtzaGVldE5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpfS50eHRgLFxyXG4gICAgdHlwZTogJ1BERicsXHJcbiAgICBjb250ZW50OiBjb250ZW50XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb3dubG9hZHMgYSBjb2RlIHRlbXBsYXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRDb2RlVGVtcGxhdGUodGVtcGxhdGVOYW1lOiBzdHJpbmcpIHtcclxuICBjb25zdCBjb250ZW50ID0gZ2VuZXJhdGVDb2RlVGVtcGxhdGUodGVtcGxhdGVOYW1lKTtcclxuICBkb3dubG9hZEZpbGUoe1xyXG4gICAgbmFtZTogYCR7dGVtcGxhdGVOYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX0uY3BwYCxcclxuICAgIHR5cGU6ICdDUFAnLFxyXG4gICAgY29udGVudDogY29udGVudFxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogRG93bmxvYWRzIGNvdXJzZSBjb2RlIGV4YW1wbGVzIGFzIFpJUFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkQ291cnNlQ29kZShjb3Vyc2VUaXRsZTogc3RyaW5nLCBsZXNzb25zOiBhbnlbXSkge1xyXG4gIGNvbnN0IGNvZGVGaWxlcyA9IGxlc3NvbnNcclxuICAgIC5maWx0ZXIobGVzc29uID0+IGxlc3Nvbi5jb2RlRXhhbXBsZSlcclxuICAgIC5tYXAoKGxlc3NvbiwgaW5kZXgpID0+IGAvLyAke2xlc3Nvbi50aXRsZX1cXG4ke2xlc3Nvbi5jb2RlRXhhbXBsZX1cXG5gKTtcclxuICBcclxuICBjb25zdCBjb250ZW50ID0gY29kZUZpbGVzLmpvaW4oJ1xcblxcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXFxuJyk7XHJcbiAgZG93bmxvYWRGaWxlKHtcclxuICAgIG5hbWU6IGAke2NvdXJzZVRpdGxlLnJlcGxhY2UoL1xccysvZywgJ18nKX1fQ29kZV9FeGFtcGxlcy50eHRgLFxyXG4gICAgdHlwZTogJ1pJUCcsXHJcbiAgICBjb250ZW50OiBjb250ZW50XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb3dubG9hZHMgcHJvamVjdCBzdGFydGVyIGNvZGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZFByb2plY3RTdGFydGVyQ29kZShwcm9qZWN0VGl0bGU6IHN0cmluZywgc3RhcnRlckNvZGU/OiBzdHJpbmcpIHtcclxuICBjb25zdCBjb2RlID0gc3RhcnRlckNvZGUgfHwgYC8vICR7cHJvamVjdFRpdGxlfSBTdGFydGVyIENvZGVcclxuI2luY2x1ZGUgPGlvc3RyZWFtPlxyXG51c2luZyBuYW1lc3BhY2Ugc3RkO1xyXG5cclxuaW50IG1haW4oKSB7XHJcbiAgICAvLyBZb3VyIGNvZGUgaGVyZVxyXG4gICAgY291dCA8PCBcIkhlbGxvLCAke3Byb2plY3RUaXRsZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyl9IVwiIDw8IGVuZGw7XHJcbiAgICByZXR1cm4gMDtcclxufWA7XHJcbiAgXHJcbiAgZG93bmxvYWRGaWxlKHtcclxuICAgIG5hbWU6IGAke3Byb2plY3RUaXRsZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3N0YXJ0ZXIuY3BwYCxcclxuICAgIHR5cGU6ICdDUFAnLFxyXG4gICAgY29udGVudDogY29kZVxyXG4gIH0pO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJkb3dubG9hZEZpbGUiLCJmaWxlIiwiYmxvYiIsImNvbnRlbnQiLCJCbG9iIiwidHlwZSIsImdldE1pbWVUeXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsIm5hbWUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwicmV2b2tlT2JqZWN0VVJMIiwibWltZVR5cGVzIiwidG9VcHBlckNhc2UiLCJnZW5lcmF0ZUNvZGVUZW1wbGF0ZSIsInRlbXBsYXRlTmFtZSIsInRlbXBsYXRlcyIsImdlbmVyYXRlQ2hlYXRTaGVldENvbnRlbnQiLCJzaGVldE5hbWUiLCJzaGVldHMiLCJnZW5lcmF0ZVppcENvbnRlbnQiLCJpdGVtcyIsImpvaW4iLCJkb3dubG9hZENoZWF0U2hlZXQiLCJyZXBsYWNlIiwiZG93bmxvYWRDb2RlVGVtcGxhdGUiLCJkb3dubG9hZENvdXJzZUNvZGUiLCJjb3Vyc2VUaXRsZSIsImxlc3NvbnMiLCJjb2RlRmlsZXMiLCJmaWx0ZXIiLCJsZXNzb24iLCJjb2RlRXhhbXBsZSIsIm1hcCIsImluZGV4IiwidGl0bGUiLCJkb3dubG9hZFByb2plY3RTdGFydGVyQ29kZSIsInByb2plY3RUaXRsZSIsInN0YXJ0ZXJDb2RlIiwiY29kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/downloadUtils.ts\n"));

/***/ })

});